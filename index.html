<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>3D Letter Network Mesh</title>
<style>
  body { margin:0; overflow:hidden; background:black; }
  .distLabel {
    position:absolute;
    color:#00ff9d;
    font-family: monospace;
    font-size: 12px;
    pointer-events:none;
  }
</style>
</head>
<body>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<div style="display:none">
  DEAD END, FAKE WEBSITE
</div>

<script>
const glyphs = "ꑇꐕꌇꌈꉕӫӪѶꃼꆜ₯฿௹∳∲∱∰∯𝖁𝖀𝕿𝕾𝕽𝖃𝖂℣".split("");

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 3000);
camera.position.z = 800;

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const group = new THREE.Group();
scene.add(group);

// Tetrahedron vertices for final formation
const tetra = [
  new THREE.Vector3(0,200,0),
  new THREE.Vector3(200,-100,200),
  new THREE.Vector3(-200,-100,200),
  new THREE.Vector3(0,-100,-200)
];

let letters = [];
let lines = [];

glyphs.forEach((g,i)=>{
  // Letter sprite
  const canvas = document.createElement('canvas');
  canvas.width = 64; canvas.height = 64;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = "white";
  ctx.strokeStyle = "white";
  ctx.lineWidth = 2;
  ctx.font = "48px monospace";
  ctx.strokeText(g, 8, 48);
  const texture = new THREE.CanvasTexture(canvas);
  const material = new THREE.SpriteMaterial({map: texture});
  const sprite = new THREE.Sprite(material);
  
  // Circle start
  const angle = i/glyphs.length * Math.PI*2;
  sprite.position.set(Math.cos(angle)*300, Math.sin(angle)*300, 0);
  group.add(sprite);
  letters.push(sprite);

  // Label
  const div = document.createElement('div');
  div.className = 'distLabel';
  div.innerText = "0 m";
  document.body.appendChild(div);
  sprite.distLabels = [div];

  // Lines array for multiple neighbors
  sprite.neighborLines = [];
});

function getNearestNeighbors(i, count=3){
  const neighbors = [];
  letters.forEach((l2,j)=>{
    if(i===j) return;
    const d = letters[i].position.distanceTo(l2.position);
    neighbors.push({index:j, dist:d});
  });
  neighbors.sort((a,b)=>a.dist-b.dist);
  return neighbors.slice(0,count);
}

// Create line objects for each letter to 3 nearest neighbors
letters.forEach((l,i)=>{
  const neighbors = getNearestNeighbors(i,3);
  neighbors.forEach(n=>{
    const geometry = new THREE.BufferGeometry().setFromPoints([l.position, letters[n.index].position]);
    const materialLine = new THREE.LineBasicMaterial({color:0x00ff9d});
    const line = new THREE.Line(geometry, materialLine);
    scene.add(line);
    l.neighborLines.push({line:line, targetIndex:n.index});
  });
});

let time = 0;
function animate(){
  requestAnimationFrame(animate);
  time += 0.01;
  const phase = (time < 6) ? "circle" : "tetra";

  letters.forEach((l,i)=>{
    let target;
    if(phase==="circle"){
      const angle = time + i/glyphs.length * Math.PI*2;
      target = new THREE.Vector3(Math.cos(angle)*300, Math.sin(angle)*300, Math.sin(time*2+i)*20);
    } else {
      const t = tetra[i % tetra.length];
      target = new THREE.Vector3(t.x, t.y, t.z);
    }
    l.position.lerp(target,0.05);
  });

  // Update lines and labels
  letters.forEach((l,i)=>{
    l.neighborLines.forEach(nl=>{
      const target = letters[nl.targetIndex];
      nl.line.geometry.setFromPoints([l.position, target.position]);
      nl.line.geometry.attributes.position.needsUpdate = true;

      // Update label at midpoint
      const mid = new THREE.Vector3().addVectors(l.position, target.position).multiplyScalar(0.5);
      const vector = mid.clone().project(camera);
      const x = (vector.x+1)/2 * window.innerWidth;
      const y = (-vector.y+1)/2 * window.innerHeight;
      l.distLabels[0].style.left = x + "px";
      l.distLabels[0].style.top = y + "px";
      const dist = l.position.distanceTo(target.position);
      l.distLabels[0].innerText = dist.toFixed(1) + " m";
    });
  });

  group.rotation.y += 0.002;
  group.rotation.x += 0.001;

  renderer.render(scene,camera);
}

// Responsive
window.addEventListener('resize',()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

animate();
</script>

</body>
</html>      target = new THREE.Vector3(Math.cos(angle)*300, Math.sin(angle)*300, Math.sin(time*2+i)*20);
    } else {
      const t = tetra[i % tetra.length];
      target = new THREE.Vector3(t.x, t.y, t.z);
    }
    l.position.lerp(target,0.05);
  });

  // Update lines and labels
  letters.forEach((l,i)=>{
    l.neighborLines.forEach(nl=>{
      const target = letters[nl.targetIndex];
      nl.line.geometry.setFromPoints([l.position, target.position]);
      nl.line.geometry.attributes.position.needsUpdate = true;

      // Update label at midpoint
      const mid = new THREE.Vector3().addVectors(l.position, target.position).multiplyScalar(0.5);
      const vector = mid.clone().project(camera);
      const x = (vector.x+1)/2 * window.innerWidth;
      const y = (-vector.y+1)/2 * window.innerHeight;
      l.distLabels[0].style.left = x + "px";
      l.distLabels[0].style.top = y + "px";
      const dist = l.position.distanceTo(target.position);
      l.distLabels[0].innerText = dist.toFixed(1) + " m";
    });
  });

  group.rotation.y += 0.002;
  group.rotation.x += 0.001;

  renderer.render(scene,camera);
}

// Responsive
window.addEventListener('resize',()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

animate();
</script>

</body>
</html>
